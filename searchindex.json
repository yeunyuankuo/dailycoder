{"categories":[{"title":"Go","uri":"https://dailycoder/categories/go/"}],"posts":[{"content":" I was asked this question in one of my recent software engineer job interviews, and I believe I didn‚Äôt answer it as well as I would have liked, so I wanted to write this blog to re-answer it and perhaps aid someone else who is also curious about the solution.\n In Go articles, we often see goroutine introduced as a lightweight thread. But why is it lightweight? how lightweight?\n Before we delve into the ‚Äúlightweight‚Äù part, we need to first understand the two components in this comparison equation ‚ÄîThread \u0026amp; Goroutine.\nWhat is a thread? In short, a thread is a basic unit of CPU utilization; it comprises a thread ID, a program counter, a register set, and a stack. It shares with other threads belonging to the same process its code section, data section, and other operating-system resources, such as open files and signals.\nWhat is a goroutine? In Go, a ‚Äúgo‚Äù statement starts the execution of a function call as an independent concurrent thread of control, or goroutine, within the same address space. The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.\nfunc main() { go fmt.Println(\u0026quot;Hello from another goroutine\u0026quot;) fmt.Println(\u0026quot;Hello from the main goroutine\u0026quot;) // At this point the program execution stops and all // active goroutines are killed. }  The function value and parameters are evaluated as usual in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete. Instead, the function begins executing independently in a new goroutine. When the function terminates, its goroutine also terminates. If the function has any return values, they are discarded when the function completes.\nGoroutine vs. Thread Each operating system thread has a fixed-size block memory (sometimes as large as 2MB) for its stack, which is the work area where it saves the local variables of function calls that are in process or momentarily halted while another function is performed. This fixed-size stack is both too big and too small. A 2MB stack would be a tremendous waste of memory for a small goroutine that simply waits for a WaitGroup before closing a channel.\nIt is not uncommon for a Go program to generate hundreds of thousands of goroutines at once, which would be difficult to stack. Regardless of size, fixed-size stacks are not always large enough for the most complex and deeply recursive routines. Changing the fixed size can improve space efficiency and allow for the creation of more threads, or it can permit more deeply recursive algorithms, but not both.\nA goroutine, on the other hand, starts with a modest stack, typically 2KB. The stack of a goroutine, like the stack of an OS thread, maintains the local variable of active and suspended function calls, but unlike the stack of an OS thread, the stack of a goroutine is not fixed; it grows and shrinks as needed. A goroutine stack‚Äôs size limit could be as much as 1GB, which is orders of magnitude larger than a conventional fixed-size thread stack; however, few goroutines use that much.\nWrapping Up In Summary, to answer the question of why goroutine is called a lightweight thread. It‚Äôs because a goroutine starts with a stack space of 2KB which is extremely smaller and more compact than OS thread\u0026rsquo;s fixed-size stack space of 2MB. However, the goroutine‚Äôs stack space is growable and it can grow and exceed the OS thread‚Äôs 2MB fixed-stack size. So a goroutine is actually only ‚Äúlightweight‚Äù in the beginning and could gradually grow ‚Äúoverweight‚Äù when needed!\nResources  Official Go Specs The Go Programming Language ‚Äî Alan A. A. Donovan and Brian W. Kernighan Operating System Concepts ‚Äî Abraham Silberschatz, Greg Gagne, and Peter Baer Galvin Professor Dr. John Bell‚Äôs lecture notes for Operating Systems Goroutines are lightweight threads   Thank you for reading! üåü If you find this article interesting feel free to leave a comment!\n","id":0,"section":"posts","summary":"I was asked this question in one of my recent software engineer job interviews, and I believe I didn‚Äôt answer it as well as I would have liked, so I wanted to write this blog to re-answer it and perhaps aid someone else who is also curious about the solution.\n In Go articles, we often see goroutine introduced as a lightweight thread. But why is it lightweight? how lightweight?","tags":["Go","Interview"],"title":"Why is goroutine being called a ‚Äúlightweight‚Äù thread?","uri":"https://dailycoder/2022/03/goroutine-lightweight/","year":"2022"}],"tags":[{"title":"Go","uri":"https://dailycoder/tags/go/"},{"title":"Interview","uri":"https://dailycoder/tags/interview/"}]}